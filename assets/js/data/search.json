[ { "title": "C# Fonksiyonel Programlama", "url": "/posts/csharp-fonksiyonel-programlama/", "categories": "Programlama, C#", "tags": "c#, programlama, fonksiyonel programlama, delegate, closure, action, func, predicate", "date": "2022-07-11 06:33:00 +0300", "snippet": "Bölüm 1 - Delegate (Temsilci) Nedir?Delegate Nedir?C#’da bulunan methodların bellek adreslerini tutmak için kullanılan yapıya delegate(temsilci) denir.Delegate Nasıl Tanımlanır?&lt;Access Modifier(public/private vs.)&gt; delegate &lt;return Type&gt; &lt;temsilci adi&gt; (parameters); Not: Burada dikkat etmemiz gereken nokta bu tanımın kendi oluşturduğumuz bir tür olmasıdır.//Örnek: public delegate void EkleDelegate(int a, int b); Bu örneği incelediğimizde tanımladığımız tür ile birlikte artık bu türden oluşturulan nesneler geriye herhangi bir şey döndürmeyen(void) ve 2 tane int parametre alan methodlara işaret edebilecektir.Delegate Nasıl Başlatılır?Temsilciyi kullanmak için ilk önce bir nesne oluşturmalı ve temsilcinin kullanacağı methodu parametre olarak iletilmesi gerekir.EkleDelegate temsilcim = new EkleDelegate (methodName);veyaEkleDelegate temsilcim= methodName;Delegate Nasıl Çağrılır?Temsilciyi çalıştırmak için ilgili temsilci istenen parametrelerle çağrılır.temsilcim(100, 50);veyatemsilcim.Invoke(100,50);Delegate Türleri Nelerdir?Single Cast DelegateTek bir methodu çağırmak için bir temsilci kullanılıyorsa buna single cast delegate veya unicast delegate denir.İlk kısımda incelediğimiz örnek single cast delegate türüne bir örnektir.Multicast DelegateBirden fazla işlevi temsil eden delegatelere multicast delegate denir. Bu türdeki bir temsilci kendisine eklenen tüm methodları çağıracaktır. Eklenen methodlar aynı şekilde method imzalarına sahip olması gerekir. Multicast delegate çağrı listesindeki(Invokation list) methodların eklendikleri sırasıyla çağrılır.Temsilciye birden fazla method iletirken + ve – operatörlerinden yararlanılır. + method eklemek için kullanılır. (System.Delegate Combine) - method çıkarmak için kullanılır.(System.Delegate Remove)public void ToplamaIslemi(int a,int b){\tConsole.WriteLine(a+b);}public void CarpmaIslemi(int a,int b){\tConsole.WriteLine(a*b);}public delegate void IslemDelegate(int a,int b);Main(){ IslemDelegate temsilci=new IslemDelegate(ToplamaIslemi); temsilci+= CarpmaIslemi; temsilci(4,5);} //Çıktı: 9 20Void dışında değer dönderen methodları temsil eden bir temsilciye birden fazla method eklendikten(multicast delegate) sonra temsilci çağrıldığında hangi değer geriye return olacaktır? Bu durumda temsilci kendisine eklenen son methodun geriye dönderdiği değeri return eder. Eğer bütün yüklenen methodların return değerlerini elde etmek istiyorsak GetInvocationList methodundan yararlanılır.public delegate int Hesapla(int a,int b);public int ToplamaIslemi(int a1, int a2){return a1 + a2;}public int CarpmaIslemi(int a1, int a2){return a1 * a2;}main(){ Hesapla temsilci=new Hesapla(ToplamaIslemi); temsilci+=CarpmaIslemi; Console.Write(temsilci(4,5));}//Çıktı: 20 //Son eklenen işlem olan çarpmanın sonucunu verirmain(){ Hesapla temsilci = new Hesapla(ToplamaIslemi); temsilci += CarpmaIslemi; Delegate[] methodlar = temsilci.GetInvocationList(); foreach(Delegate item in methodlar){ int sonuc = item.DynamicInvoke(4,5); //veya int sonuc = ( (Hesapla) item).Invoke(4,5); Console.WriteLine(sonuc); } }//Çıktı: 9 20 //eklenme sırasıyla toplama ve çarpma işlemi sonucuGeneric delegate türleri nelerdir?Action DelegateBir veya daha fazla girdi parametresi alır ve hiçbir şey döndürmeyen(void) türdeki methodları işaret edebilen delegate türüdür. Farklı veya aynı türden max 16 parametre alabilir.Action temsilci = methodName; temsilci();Action&lt;parametre1,parametre2 ,,,,n&gt; temsilci = methodName;temsilci(parameters);Func DelegateBir veya daha fazla giriş parametresi alır ve 1 çıkış parametresi döndürür. Son parametre dönüş değeri(return) olarak kabul edilir. Farklı veya aynı türden max 16 parametre alabilir. Not: Dönüş türü zorunludur ancak giriş parametresi zorunlu değildir.Func&lt;params , Return Type&gt; funcTemsilci;//Geriye int döndüren ve hiçbir parametre almayan methodlara işaret eden temsilci örneği\tFunc&lt;int&gt; temsilci=methodName; int x=temsilci();//Geriye string değer döndüren ve int tipinde bir değer alan methodlara işaret eden temsilci örneğiFunc&lt;int,string&gt; temsilci=methodName; string x=temsilci(5);Predicate Delegate1 giriş parametresi alan ve her zaman Boolean tipinde değer dönderen delegate türüdür.Predicate&lt;T&gt; = Func&lt;T, bool&gt; diyebiliriz.//int parametre alan ve geriye boolean değer dönderen methodları işaret eden temsilci örneğiPredicate&lt;int&gt; temsilci=methodName; bool x=temsilci(9);Anonymous Method/Delegate Nedir?Adında da anlaşılacağı gibi, anonim bir method adı olmayan bir methodtur. C#’ daki anonim methodlar delegate anahtar kelimesi kullanılarak tanımalanabilir ve bir delegate türü değişkenine atılabilir.Notlar; Anonim yöntem delegate anahtar sözcüğü kullanılarak tanımlanabilir. Anonim yöntem dış değişkenlere veya methodlara erişebilir. Anonim yöntem parametre olarak iletilebilir. Anonim yöntemde return type ın belirtilmesine gerek yoktur. Method gövdesinin içindeki return ifadesinden çıkarılır.public delegate void Yaz(string kelime);main(){\tYaz temsilci = delegate (string x){\t Console.Write(x); };\ttemsilci(“selim”);}//Çıktı: selimDelegate Covariance and Contravariance// Örnek Classlarpublic class Small { }public class Big: Small{}public class Bigger : Big{ }main(){ Small smlCls1 = new Small(); //çalışır Small smlCls2 = new Big(); //çalışır Small smlCls3 = new Bigger(); //çalışır Big bigCls1 = new Bigger(); //çalışır Big bigCls2 = new Small(); //çalışmaz} Yukarıdaki instance örnekleri incelendiğimizde temel sınıf türetilmiş sınıfların örneklerini kabul ederken türetilmiş sınıflar temel sınıf örneğini kabul etmemektedir.CovarianceCovariance, bir temel sınıfın beklendiği yerde türetilmiş bir sınıf kullanılmasına izin verilmesidir. Covariance delegate, array, interface vb. yapılar ile uygulanabilir.Delegate CovarianceDelegate methodlarının dönüş türünde(returnType) esnekliğe izin verir.class Hayvan{}class Cita:Hayvan{} delegate Hayvan hayvanTemsilcisi(); Hayvan hayvanFonk(){}Cita citaFonk(){ }main(){hayvanTemsilcisi temsilci = hayvanFonk; // çalışırhayvanTemsilcisi temsilci = citaFonk; // çalışır}Main methodun içerisine baktığımızda temsilcinin return değeri hayvan sınıfından olmasına rağmen hem hayvan sınıfı dönderen bir methodu hem de cita sınıfı dönderen bir methodu işaret edebilmiştir. Buna delegate covariance denir.Return değerleri için bu durum kabul edilsede maalesef aynı işlem parametrelerde mümkün olmamaktadır.class Hayvan{}class Cita:Hayvan{} delegate void hayvanTemsilcisi(Hayvan parametre); void hayvanFonk(Hayvan parametre){}void citaFonk(Cita parametre){}main(){hayvanTemsilcisi temsilci = hayvanFonk; // çalışırhayvanTemsilcisi temsilci = citaFonk; // çalışmaz}Yukarıdaki örneğin Main methodunu incelediğimizde temsilci Hayvan sınıfı tipinde parametre desteklediği için hayvanFonk methodunu işaret edebilirken, citaFonk methodunu işaret edememektedir. Genelde bu kısım kafa karıştırıcı gelmektedir. Çünkü Cita zaten Hayvan sınıfından türetilmişse nasıl Cita tipinde bir parametre alan methodu delegate kabul edemez gibi düşünülebilir. Fakat buradaki önemli kısım temsilcinin davranışıdır. Eğer Cita’yı kabul edecek olsa, Hayvan sınıfından türeyen örneğin Kaplan sınıfınıda geçebilmemize olanak sağlayacaktı. Bu şekilde delegate’e geçilecek methodun ne olacağı kısmı netliğini kaybederdi. Peki böyle bir davranış istersek ne yapmamız gerekiyor? İşte tam da bu noktada diğer kavramımız olan delegate contravarince incelememiz gerekiyor.Delegate ContravarianceBir temel sınıfın parametresine sahip bir methodun, türetilmiş bir sınıfın parametresini bekleyen temsilciye atanmasına izin verir.class Hayvan{}class Cita:Hayvan{} delegate void hayvanTemsilcisi(Cita parametre); void hayvanFonk(Hayvan parametre){}void citaFonk(Cita parametre){}main(){hayvanTemsilcisi temsilci = hayvanFonk; // çalışırhayvanTemsilcisi temsilci = citaFonk; // çalışır}Bu örnekteki main methodu incelediğimizde temsilcimizin parametre tipi Cita olmasına rağmen hem hayvanFonk hem de citaFonk methodlarına işaret edebilmektedir. Bu güvenlidir. Burada şöyle düşünebilir temsilcinin parametresi olan Cita kendisine geçirilen methodun tipine (Hayvan) dolaylı olarak typecast edilir.Ekstra BilgilerNot 1: Delegate isimlendirirken ismin sonunu Handler ile birmek bir yazılım geleneğidir. public delegate void BenimTemsilcimHandler();Not 2: İçerisinde bir method işaret edilmemeş temsilciler çağrıldığında Örneğin: temsilci(5)Bu durumda NullReferenceException hatası alınmaktadır. Bu duruma sebebiyet vermemek için temsilcinin null kontrolü yapılması daha sağlıklı olacaktır.if(temsilci!=null){ temsilci(5);}//veyatemsilci?.Invoke(5)Bölüm 2 - Event(Olay) Nedir?Özelleştirilmiş temsilciler(delegate) gibi düşünülebilir. Örneğin bir butona tıklanması, farenin hareket etmesi gibi olaylar bir event oluştururlar.Event Nasıl Tanımlanır? Delegate tanımlayın. Event anahtar kelimesini kullanarak delegate türünde bir değişken bildirin.public delegate void Hesapla(); //delegate tanımıpublic event Hesapla IslemTamamlandi; //event tanımıEvent’ın bulunduğu sınıfa yayıncı(publisher), bu event’a kayıt olanların bulunduğu sınıflara ise abone(subscriber) sınıfı denilmektedir.Bir sınıf event’a abone olmak için += operatörünü kullanmaktadır.Abonelikten ayrılmak için -= kullanılmaktadır. Delegatelerde bulunan = operatörü ise eventlerde kullanılmamaktadır.Yukaridaki örnekte delegate’i tanımlamamız bize event’a abone olacak methodların geri bir şey döndermeyen (void) ve herhangi bir parametre almayacağını belirtmektedir.Event’e Abone İşlemi Nasıl Gerçekleştirilir? IslemTamamlandi += methodName;Bu şekilde ilgili event’a abone olunur.Event’i Çağırma Nasıl Gerçekleştirilir? IslemTamamlandi();Görüldüğü gibi tanımladığımız event’i çağırarak event’a abone olan tüm methodlar yürütülecektir.EventHandler Nedir?C# da olaylar için tanımlanan yerleşik delegatelerden birisidir. Bir event’i incelediğimizde 2 parametre içermelidir.EventHandler(object sender,EventArgs e)Bunlar; Olayın kaynağı (sender) Olay verileri (e)Buradaki object tipinden sender event’i başlatan objeyi ikinci parametre olan EventArgs tipinden e ise olay verilerini tutar. Eğer event olay verisi üretmezse ikinci parametre EventArgs.Empty değeridir. Eğer olay verisi içeriyorsa ikinci parametre EventArgs’tan türetilen bir türdür.EventHandler olay verilerini içermeyen tüm event’ler için kullanılabilir. Olay verilerini içeren event’lar için EventHandler&lt;TEventArgs&gt; delegate’i kulanılabilir.Örneğimizi EventHandler delegate ile ifade edecek olursak artık Hesapla delegatine ihtiyacımız kalmamaktadır. Direk aşağıdaki şekilde tanımlanabilir.public event EventHandler IslemTamamlandi; //event tanımıIslemTamamlandi( this , EventArgs.Empty); //eventi çağırma//Buradaki this çağıran nesneyi EventArgs.Empty ise herhangi bir olay verisi olmayacağını belirtmektedir.Yukarıdaki örnekte olay verisi içermeyen bir örnek yaptık. Olay verisi içeren bir event tanımalamak istersek aşağıdaki yapıyı kullanarak yapabiliriz.public event EventHandler&lt;bool&gt; IslemTamamlandi;Bu şekilde bu event’a abone olacak methodların bir bool değişken içereceğini belirtmiş oluyoruz. Bu event’a çağrıyı ise aşağıdaki gibi güncelliyoruz.IslemTamamlandi(this, bool variable); //event’i çağırmaEğer olay verisi olarak birden fazla değer iletmek istersek EventArgs sınıfından türetilen bir sınıf oluşturup o sınıftan yararlanmamız gerekir. Örnekclass IslemTamamlandiArgs : EventArgs{\tpublic bool IslemSonucu;\tpublic DateTime IslemYapilmaZamani;}Artık bu sınıfı EventHandler’a belirterek kullanabiliriz.public event EventHandler&lt;IslemTamamlandiArgs&gt; IslemTamamlandi;Şimdi abone olacak sınıfımızda IslemTamamlandıArgs sınıfından bir nesne oluşturup değerlerini belirtip event methoduna iletebiliriz.IslemTamamlandiArgs cokluData= new IslemTamamlandiArgs();cokluData.IslemSonucu=true;cokluData.IslemYapilmaZamani=DateTime.Now;IslemTamamlandi(this, cokluData); //event’i çağırmaBölüm 3 - Lambda Expression (Lambda İfadeleri)Tanım: Sadeleştirilmiş anonim methodlardır.Örnek: Verilen değerin 2 katını dönderen methodu yazınız.int iki_Kati(int deger)\t\t{\treturn 2 * deger;}Sorunun cevabı için yukarıdaki gibi bir method yazacaktık.Peki bu methodu lambda ifadesi olarak nasıl yazabiliriz?Bu soruyu cevaplarken tanımı tekrar hatılayalım sadeleştirilmiş anonim methodlardır. Altı çizili kısma dikkat edersek C# da anonim methodların delegateler yardımıyla oluşturulduğunu bir önceki bölümden hatırlayalım.\tO zaman yukarıdaki methodu delegate ile bir anonim method haline getirelim.delegate (int deger){\treturn 2 * deger;};Yukaridaki kod bloğunda methodun anonim hali gösterilmektedir. Artık sırasıyla bu methodu lambda ifadesi haline getirelim.Bu noktada anonim methodun delegate ifadesini kaldırıp, süslü parantezleri de lambda işlecine =&gt; çevirirsek methodun yeni hali(int deger) =&gt; return 2 * deger ;Bu ifade 2 * deger ifadesi de tek bir ifade belirttiğinden return ifadesini de kaldırabiliriz. Bu bizi aşağıdaki sonuca götürecektir.(int deger) =&gt; 2 * deger ;Bu kısımda dilersek artık parametrenin tipini de belirtmeyebiliriz. Yani (int deger) kısmını sadece (deger) olarak değiştirebiliriz.(deger) =&gt; 2 * deger ;Son olarak (deger) tek bir parametre olduğu için ( ) parantezlerini ve sondaki noktalı virgülü kaldırabiliriz. Ama birden fazla parametre gerektiği durumlarda parantez kullanmamız şarttır.deger =&gt; 2 * deger Son haline baktığımızda artık ifadenin tek satırla ifade edilmesi mümkün olmuştur. Bu şekilde tek satırlı olan lambda ifadelerine ifade lambdaları (expression lambdas) , çok satırlı lambda ifadelerine ise komut lambdaları (statement lambdas) denir. Komut Lambda Örneğix =&gt; { if(x&gt;5){ \treturn true; } else{\treturn false; }};Bir parametresiz lambda ifadesi kullanmak için aşağıdaki yapılar kullanılabilir.() =&gt; { // yapılacaklar };//veya() =&gt; birMethod(); Not: Lambda ifadelerine sıklıkla başvurulan noktalardan birisi LINQ sorgularıdır.Bazı C# tanım örnekleri:-\tAction action = () =&gt; { Console.Write(\"Action Calisti.\"); }; action();\t //Çıktı : Action Calisti.-\tFunc&lt;int,int&gt; func = y =&gt; { return 10+y; }; func(5); //Çıktı: 15-\tFunc&lt;string,int,string&gt; func = (ad,no) =&gt; { return ad+no.ToString(); }; Console.Write(func(\"selim\",27)); //Çıktı: selim27Bölüm 4 - Closures(Kapanışlar)Wikipedia tanımını inceleyecek olursak. “Bir kapatma(closure), sözlüksel ortama bağlı(lexical scope) serbest değişkenlere(free variables) sahip birinci sınıf bir işlevdir(first-class function).”Şimdi tanımdaki kavramları inceleyelim.Birinci Sınıf İşlev(first-class function) : Yine wikipedia’dan tanımına bakarsak “Bir programlama dili, işlevleri birinci sınıf vatandaşlar olarak ele alıyorsa, birinci sınıf işlevlere sahip olduğu söylenir.”Bu ifade programlama dilinin; İşlevlerini diğer işlevlere argüman olarak iletmeyi İşlevleri diğer işlevlerden değerler olarak döndermeyi İşlevleri değişkenlere atamayı İşlevleri veri yapılarında depolamayıdesteklediği anlamına gelir. Ve C# da temsilciler(delegate) kullanarak bu maddeleri gerçekleştirebilmekteyiz.Action _myAction = delegate{ Console.WriteLine(\"Selim Gezer\");};_myAction(); //Çıktı: Selim GezerYukarıdaki örnek C#’ın birinci sınıf işlevleri destekleğini göstermektedir.Serbest Değişken (free variable) : İşlevin parametresi veya işlevin yerel değişkeni olmayan bir işlevde başvurulan değişkendir.string memleket = \"Gaziantep\";Action _myAction= delegate{ Console.WriteLine(\"Selim Gezer \"+ memleket);};_myAction(); //Çıktı: Selim Gezer GaziantepBu örneği incelediğimizde _myAction değişkenimizin dikkat ederseniz kendi parametresi olmayan ve yerel değişkeni olmayan memleket değişkenine başvurmaktadır. Bu bir serbest değişkendir. İster yerel olsun ister serbest değişken olsun ne oluyor yani denilebilir. Hemen tanımı hatırlayalım bu bir kapatma(closure) oluşturmaktadır.Konuyu daha iyi için aşağıdaki örnekleri inceleyelim.int sayi = 1;Action _myAction= delegate{ Console.WriteLine(\"{0} + 1 = {1}\", sayi, sayi + 1);};_myAction(); //Çıktı: 1 + 1 = 2Örneği incelediğimizde sayi adlı bir değişken ve Action tipinde bir methodu işaret edecek bir değişken bulunmaktadır. Burada dikkat etmemiz gereken nokta _myAction değişkeni kendi kapsamında bulunmayan bir değişken olan sayi değişkenine erişmektedir. Tanım gereği bu bir closure oluşturmakta olduğunu söylemiştik. Ve çıktı olarak 1+1’den 2 elde edilmiştir. Belki bu kısımda tam olarak ne yapılmak istendiğini anlamamış olabilirsiniz. Aynı örneği kapsam değiştirerek inceleyelim.class Program{ static Func&lt;int,int&gt; _myFunc; static void Main(string[] args) { DigerMethodum(); Console.WriteLine(\"ilk çağrı:\"+_myFunc(1)); //Çıktı: 1 + 2 = 3 Console.WriteLine(\"ikinci çağrı:\"+_myFunc(2)); //Çıktı: 2 + 3 = 5 } private static void DigerMethodum() { int sayi = 1; _myFunc = (int deger) =&gt; {\t\tsayi++;\t\treturn deger+sayi; }; }Bu örneğe çok dikkat edelim. İlk baktığımızda global kapsamda bir Func&lt;int,int&gt; tipinde _myFunc adlı bir değişken bulunmaktadır. Main method içerisinde DigerMethodum çağrılmaktadır. Ve DigerMethodum içerisinde sayi değişkeni ve _myFunc’ın işaret edeceği method bulunmaktadır. Ve bu method ilk başta sayi++ diyerek sayinin değerini 1 arttırıp soransında kendisine gelen parametre olan deger ile sayi değişkenini toplayarak geriye döndermektedir. DigerMethodum çağrısından sonra Main method içerisinde 2 defa _myFunc temsilcisinin işaret ettiği method çağrılmıştır.Şimdi çıktıları inceleyelim. İlk _myFunc(1) çağrısı yapılmaktadır.Sırasıyla inceleyelim. sayi başlangıçta=1 ‘dir.sayi++ ile sayi artik = 2 olmuştur. Daha sonra return deger+sayi ise 2 + 1 ‘den 3 olarak dönmektedir. Ve çıktı 3’tür. Buraya kadar herhangi bir şey gözlemlemedik. Sonuçlar çoğu geliştiricinin beklediği şekildedir.Şimdi 2. Çağrı olan _myFunc(2) inceleyelim. sayi başlangıçta=2’dirsayi++ ile sayi artık=3 olmuştur. Daha sonrareturn deger + sayi ise 2 + 3 ‘den 5 olarak dönmektedir.Evet tam da burada bizi şaşırtan bir sonuç oluşmaktadır. Direk bakıldığında çıktının 4 olduğu söylenecektir. Neden. Sayi++ sayiyi 2 yapacaktır. Gelen değerde 2 o zaman 2+2 ‘den 4 olacaktır. Fakat dikkat ettiniz mi sayi son değerini koruyup kaldığı değeri arttırarak işlem yapmaktadır. Hemen akla şu soru gelmektedir. Ee çağırdığımız fonksiyonlar işleri bittikleri zaman temizlenmezlermi? EVET normalde öyle olması beklenir. Ama burada sayi değişkeni kapsamı dışında da yaşamaya devam etmektedir. C#’da bir yerel değişkenin ömrü ona başvuran tüm kapanışların ömrünü içerecek şekilde uzatılır.Ve temsilciye referansımız bulunduğu müddetçe de yaşamaya devam edecektir. İşte bu olay tam olarak closure(kapanış)’durBu sihirli davranış için C# derleyicinin davranışı araştırılabilir. Şimdi başka ilginç örneklere geçelim.public delegate void SayiDelegate(); main(){\t SayiDelegate delegateObjesi = null; for (int i = 1; i &lt;= 3; i++) { delegateObjesi += () =&gt; Console.WriteLine( i ); } delegateObjesi(); }//Çıktı: 4 4 4 (3 tane 4 bastırmıştır.)Bu çıktının sizi çok şaşırttığını biliyorum. Genelde yeni başlayan geliştiriciler bu çıktının 1 2 3 vereceğeni düşünmektedir. Aslında kısmen haklıdırlar fakat kaçırdıkları kavram closure’dur. Çünkü dikkat ederseniz for döngüsüyle her seferinde delegateObjesi += () =&gt; Console.WriteLine( i );ile delegateObjesine işaret ettirilen lambda ifadesi i değişkenine başvurmuştur. Ama bu tanım gereği closure oluşturmaktadır. Çünkü i lambda fonksiyonun kendi parametresi veya yerel değişkeni değildir.Peki çıktı nasıl oluştu ?delegateObjesi(); çağrıldığında içerisindekiler InvocationList ‘ göre sırasıyla tetiklenecektir.Yani aşağıdaki şekilde.ConsoleWriteLine(i);ConsoleWriteLine(i);ConsoleWriteLine(i);Peki nedenConsoleWriteLine( 1 );ConsoleWriteLine( 2 );ConsoleWriteLine( 3 );bu şekilde değil.Çünkü C#’da kapanışlar(closure) değişkenlerin değerlerini değil referanslarını yakalarlar.(Aşağıdaki resmi inceleyiniz) Zaten o yüzden çıktı olarakta 3 tane 4 elde etmekteyiz.Peki nasıl olsaydı ilk düşündüğüz gibi çıktı olarak 1 2 3 bastırılırdı?public delegate void SayiDelegate(); Main(){\t SayiDelegate delegateObjesi = null; for (int i = 1; i &lt;= 3; i++) { int kopya=i; delegateObjesi += () =&gt; Console.WriteLine( kopya ); } delegateObjesi(); }//Çıktı: 1 2 3 Evet örneğe sadece ekstra bir değişken ekleyerek(int kopya) istediğimiz sonucu elde etmekteyiz. Ee ne farkı var i ‘ yi başka değişkene attık diyebilirsiniz. Ama şuna dikkat etmekte fayda var az önceki for döngüsünde direk i ‘yi kullandığımızda i bir taneydi yani hep aynı adres üzerinde işlem yapılmaktaydı(Şekil 4.1). Fakat burda her iterasyonda yeni bir kopya değişkeni oluşturmakta ve yeni adrese i ‘nin değeri atılmaktadır(Aşağıdaki resmi inceleyiniz.).Diğer bir örnek:main() { int i = 0; Action increment = delegate { ++i; }; Console.WriteLine(i); ++i; Console.WriteLine(i); increment(); Console.WriteLine(i); ++i; Console.WriteLine(i); increment(); Console.WriteLine(i); }//Çıktı: 0 1 2 3 4Diğer bir örnek:var list = new int[] { 0, 1, 2, 3 }; //closurevar funcList = new List&lt; Func&lt;int&gt; &gt;();var funcList2 = new List&lt; Func&lt;int&gt; &gt;();foreach (var item in list){ funcList.Add(() =&gt; item);}funcList.ForEach(f =&gt; Console.WriteLine( f() )); // Çözüm1for (var i = 0; i &lt; list.Length; i++){ funcList2.Add(() =&gt; list[i]);}funcList2.ForEach(f =&gt; Console.WriteLine( f() )); // Çözüm2//Çıktı(Çözüm1) : 0 1 2 3 //Çıktı(Çözüm2) : System.IndexOutOfRangeExceptionBu örneğimiz Çözüm1 yazılı satırımız bize beklediğimiz çıktıyı yani 0 1 2 3 bastırmıştır. Fakat Çözüm2 yazılı satırımız IndexOutOfRange hatası döndermiştir? Neden ? Hemen üzerindeki for döngüsünü inceleyelim ne yapmakta? funcList2 listesine her bir iterasyonda () =&gt; list[i] şeklinde bir lambda ifade eklemektedir. Fakat önceki örneklerden hatırlayın i değişkenine direk başvurulmaktadır. Bu da bütün iterasyonda aynı adres üzerinde çalışacak demektir. Yani yine for döngüsü bittiğinde i=4 olmaktadır. Sonraki satırda ise çağrıldığında Console.WriteLine(list[4]) şeklinde çağrılacağından list’in 4 indexli bir değeri olmadığından hata fırlatacaktır.Bölüm 5 - Kaynakça https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/covariance-contravariance/ https://www.tutorialsteacher.com/csharp/csharp-covariance-and-contravariance http://sonergonul.net/csharp-delegate-tipine-genel-bir-bakis/ https://www.kazimcesur.com/c-covariance-ve-contravariance/ https://codepureandsimple.com/covariance-and-contravariance-with-c-410fc4102a02 https://www.topcoder.com/thrive/articles/Invariance https://dotnettutorials.net/lesson/delegates-csharp/ https://www.infoworld.com/article/2996770/how-to-work-with-delegates-in-csharp.html https://www.gencayyildiz.com/blog/cta-delegatetemsilci-ve-eventolay-kullanimi/ https://yasirkula.com/2019/10/29/unity-c-delegate-ve-eventler/ https://www.yusufsezer.com.tr/csharp-delegate/ https://yazilim.cevapsitesi.com/Makaleler/2/cSharp-lambda-ifadeleri-lambda-expressions https://docs.microsoft.com/en-us/dotnet/api/system.eventhandler?view=net-5.0 https://www.fibiler.com/Divisions/Ehil/Mecmua/Magazines/Articles/txt/html/article_DelegateAndEventInCSharp.html https://pvs-studio.com/en/blog/posts/csharp/0468/ http://www.sumeyraakbiyik.com/delegete-nedir-nasil-kullanilir/ http://www.blackwasp.co.uk/CSharpClosures2.aspx/ https://www.simplethread.com/c-closures-explained http://www.macoratti.net/16/09/c_closu1.html https://medium.com/yaz%C4%B1l%C4%B1ma-dair/javascript-closures-8b5db7294941 https://codingberry.com/dotnet/2020/02/02/csharp-closure.html http://en.wikipedia.org/wiki/Closure_(computer_science) . https://stackoverflow.com/questions/271440/captured-variable-in-a-loop-in-c-sharp https://stackoverflow.com/questions/9591476/are-lambda-expressions-in-c-sharp-closures https://www.alanzucconi.com/2021/03/13/delegates-lambda-closures/ " }, { "title": "Bit - Byte Representation and Manipulation", "url": "/posts/bit-representation-and-manipulation/", "categories": "Bilgisayar Bilimi", "tags": "programlama, bit, byte, endiannes, encode, karakter set, mojibake, ascıı, unicode, logic gate, mantık kapıları, utf, ikili sayı sistemi", "date": "2021-03-05 13:43:00 +0300", "snippet": "Bit - Byte KavramlarıSayı SistemleriGünlük hayatımızda sayıları 10’luk biçimde ifade ederiz ve 10’luk sistemde sayıları ifade edebilmek için 10 simgemiz bulunur. Bunlar {0,1,2,3,4,5,6,7,8,9} şeklindedir. Bir örnek üzerinden gidecek olursakta 3 haneli(basamaklı) bir sayı yazacağımızı düşünün. Bu sayının her hanesi bu 10 sembolden birisini alma şansına sahip olabilir. 2’lik biçimdeki gösterimde ise aynı mantıkla düşünürsek gösterim için 2 sembolu bulunur. Bunlar {0,1} şeklindedir. Ve yine 3 haneli bir sayı yazdığımızda her hane bu sefer 2 sembolden birini alabilme şansına sahip olacaktır.Basamak Kavramı10’luk sistemdeki hanelerimiz diğer bir adıyla basamaklarımız şu şekilde adlandırılır.Örneğin 1234 sayısının basamaklarına bakarsak. Sağdan sola şeklinde ilerler ve her basamak aslında 10’un bir sonraki kuvveti olacak şekilde büyür. 1 2 3 4 Binler Yüzler Onlar Birler 10^3 10^2 10^1 10^0 Buradan da sayıyı çözümlediğimizde aslında 10’nun belirli kuvvetlerinde toplam gerçekleştirdiğimizi görürüz. Herhalde neden 10’luk sistem dendiği daha açık olmuştur. :) 1234 = 1 tane 1000 (10^3) + 2 tane 100(10^2) + 3 tane 10(10^1) + 4 tane 1(10^0)Şimdi aynısını 2’lik sistemdeki 4 haneli 1010 sayıyı için düşündüğümüzde yine sağdan sola şekilde ama bu sefer bir fark var basamaklar 2’nin kuvvetleri şeklinde büyüyürek ilerler. 1 0 1 0 Sekizler Dörtler İkiler Birler 2^3 2^2 2^1 2^0 2’lik sistemdeki her basamağa bit denir.Bakış Açısı ve Okunuş_ _ _ = 3 haneli(basamaklı) sayı10’luk sistem bakış açısı :       En büyük 3 haneli sayıyı yazalım dersek ne yaparız hemen elimizde 10’luk sistem sembollerinden en büyüğünü yan yana getirir söyleriz ki bu durumda bu sayı 9 9 9 dan 999 olur. Ve bunu okurken basamaklarından faydalarınız. “Dokuz yüz doksan dokuz” şeklinde okuruz.2’lik sistem bakış açısı :       En büyük 3 haneli sayıyı yazalım dediğimiz noktada 2’lik sistem sembollerinden en büyüğünü yan yana getirip söylersek bu durumda 1 1 1 den 111 sonucunu elde ederiz. Ama bunu 10’luk sistemdeki “Yüz on bir şeklinde okumayız !”. Direk hane hane yani “Bir bir bir” şeklinde okuruz.DönüşümBiçimler arasında dönüşüm yapmak mümkündür. Bu noktada 10’luktan 2’liğe veya tam tersi 2’likten 10’luğa geçişler ihtiyaca göre yapılabilir. Az önce 2’lik sistem bakış açısında elde ettiğimiz 111 sayısının 10’luğa çevirmek isteğimizde direk basamaklarını 2’nin kuvvetleri şeklinde çözümlersek 10’luk sonucunu elde edebiliriz. 111 = 1*2^2 + 1*2^1 + 1*2^0 şeklinde toplarsak 7 yapar bu demek oluyor ki2’lik 111 ifadesi 10’luk 7 sayısına denk geliyor.Peki 10’luktan 2’liğe nasıl döneriz ? Burada farklı teknikler mümkün olmakla beraber genelde en bilineni olan bölme tekniği ile 2’lik değerini bulabiliriz. Aşağıdaki resimde 79 sayısının 2’lik karşılığının nasıl bulunduğunu gözlemleyelim. Sayıyı 2’ye bölemeyinceye kadar 2’ye bölüyoruz. Bölemediğimiz noktadaki bölenden başlayıp tüm kalanları yanına eklemeye başlıyoruz. Resimdeki mor okun yönüne dikkat edin. Sonuç olarak 79 sayısı 2’lik olarak 1001111 ile temsil edildiğini buluyoruz. Tabi bilgisayarlı sistemlerde en düşük 8 bit kullanıyoruz demiştik. O yüzden sayımızı 8 bit bir şekle getirmek için sol baştan 0 ekleyebiliriz. 79 sayısıda 2’lik olarak 7 bit ile temsil edildiğinden 8 bite tamamlamak için 1 tane 0 eklememiz yeterli olacaktır. Nihai sonucumuz 01001111 şeklindedir.Peki bilgisayarlar neden 10’luk yerine 2’lik sistem kullanıyor ? Bunun aslında temel sebebi gün sonunda aslında her şeyin elektrik sinyalleri olması ve bu sinyaller genellikle 2 farklı durum göstermesi. Elektik var (HIGH) veya Elektrik yok (LOW) Diğer bir sebep basitlik denebilir 10 luk sistem olsaydı 10 farklı durumla baş etmek gerekirken 2’likte sadece 2 farklı durumla baş etmenin gerekmesi. Bilgisayar içerisindeki hesapların belirli mantıksal işlemler gerektirmesi ve bunun da aslında boole cebrine dayanması ve boole cebrininde 0 ve 1 ler üzerine kurulu olması. Yani aslında 2’lik sisteme paralellik göstermesi. Her ne kadar 2’lik sistem ve bit lerden bahsetsekte tekil halde bir bit bilgisayar için direk bir anlam ifade etmemektedir. Onun yerine bit gruplarının bir araya gelerek oluşturduğu byte kavramı kullanılmaktadır. Ve 1 byte 8 bit e tekabül etmektedir.Bit - Byte ilişkisini aşağıdaki tabloyu inceleyerek gözlemleyebiliriz. Birim Adı Kısaltma Büyüklük (bit cinsinden) Açıklama Bit b 1 bit En küçük veri birimi Byte B 8 bit 1 byte = 8 bit Kilobyte KB 8,192 bit 1 KB = 1,024 byte Megabyte MB 8,388,608 bit 1 MB = 1,024 KB Gigabyte GB 8,589,934,592 bit 1 GB = 1,024 MB Terabyte TB 8,796,093,022,208 bit 1 TB = 1,024 GB Petabyte PB 9,007,199,254,740,992 bit 1 PB = 1,024 TB Sayı sistemlerini ifade ederken programlamada kullanılan ön ekler ve son ekler nelerdir ?Sayıların hangi sistemde ifade edildiğini anlamak için bazı ön ekler ve son ekler kullanılabilir.Ön ekler : 10’luk için 0d bazı diller için desteklenir. Ama genellikle bir ek kullanılmaz. 2’lik için 0b 16’lık için 0xYani 10’luk sistemde 33 sayısı demekle 0d33 aynı şeyi ifade eder. Yine 2’lik sistemde 1101 demekle direk 0b1101 şeklinde yazmak arasında bir fark bulunmamaktadır. Bazı dökümanlar veya kaynaklarda görürseniz şaşırmayın!Son ekler : 2’lik için b 16’lık için hYani 16’lık sistemdeki FF ile FFh aynı anlama gelmektedir. Yine 2’lik 1010 ile 1010b yine aynı anlama gelmektedir.16’lık gösterim nedir ve neden gereklidir ?İkilik sistemin doğrudan bilgisayar için çok uygun olduğunu yukarıdaki anlatımlar sonrası farketmiş olabiliriz. Ama 2’lik sistemi insanlar için okumak ve yazmak zor ve uzun olabilir. O nedenle daha rahat hareket etmek için 16’lık sistemden yararlanılmaktadır. Yine yukarıdaki mantıkla 16’lık sistemde 16 sembolümüz olduğunu düşünebiliriz. Kesinlikle doğru düşündünüz ama ufak bir fark olacak. Sembollerimiz : {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15} şeklindedir. Fakat bu noktada ufak bir hareket yapılıp 2 haneli semboller tek haneli ifade edilebilmek için karakterlerden yararlanılır.Yani sembollerimizi güncellersek : {0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F} halini almış olur.2’likten 16’lığa da dönüşüm mümkündür. Bunun için bitler 4’lü gruplara ayrılır. (Neden 4’lü grup demeden hemen cevaplayalım. Çünkü 16’lıkta 16 sembolüm bulunduğu için bit seviyesinde düşünürsek bunları 4 bitle temsil edebilirim) Sonrasında her 4’lünün kendi içerisinde 16’lık karşılığı hesaplanır ve en son hesaplanan bu değerler birleştirilir.Örneğin : 0b10100001 ifadesinin 16’lık karşılığı nedir ?10100001 ifademizi 4’lü gruplara ayıralım. 1010 0001 . Şimdi her grubu kendi içinde 16’lık sisteme göre hesaplarsak 1010 = 10’a denk gelir ve 16’lıkta bu A karakteridir. 0001 = 1’e denk gelir. Sonuçlar birleştirilir.0xA1 sonucu elde edilmiş olur. 10’luk 2’lik 16’lık 0d161 0b10100001 0xA1 Sayıların sistemler arasındaki geçişini aşağıda gözlemleyelim. 10’luk 2’lik 16’lık 0 00000000 00000000 1 00000001 00000001 2 00000010 00000010 3 00000011 00000011 4 00000100 00000100 5 00000101 00000101 6 00000110 00000110 7 00000111 00000111 8 00001000 00001000 9 00001001 00001001 10 00001010 A 11 00001011 B 12 00001100 C 13 00001101 D 14 00001110 E 15 00001111 F 31 00011111 1F 186 10111010 BA 255 11111111 FF Sayılar büyüdükçe 2’liklerin ne kadar okunurluğunu yitirdiğini fark edebiliriz. Ve yine bu noktada 16’lığın nispeten daha rahat takip etmemize yardımcı olduğunu görebiliriz.Bit Representation (Temsili)Tam Sayılar Bellekte Nasıl Temsil Edilir ?Tam sayı türleri programlamada bir sayının virgülsüz halini temsil etmek için kullanılmaktadır.Buradan hareketle az biraz bile programlama dillerinde gezindiysek tam sayıları ifade etmek için farklı şekillerde türler olduğu gözlemleyebiliriz. Bu türler genellikle bellekte kapladıkları alana, işaretli (signed) ya da işaretsiz (unsigned) olup olmamalarına göre ayrılırlar. Unsigned ve signed detaylarını yazının ilerleyen kısmındaki bit manipulasyonu başlığı altında detaylı inceleyeceğiz.Aşağıda bahsedilen terimlerin açıklamalarını içeren tabloyu inceleyebilirsiniz. Terim Açıklama Signed (işaretli) Negatif veya pozitif sayılar içerebilir (örn. -10, 0, 42). Unsigned (işaretsiz) Sadece pozitif sayılar içerebilir (örn. 0, 100). bit Bellekte ne kadar yer kapladığını belirtir (8-bit = 1 byte). Burada ufak bir programlama tarafından göz gezdirecek olursak C tarafında tam sayıları temsil etmek için short, unsigned short, int, unsigned int, long gibi türler bulunmakta iken Java tarafında byte, short, int, long gibi sadece signed türler bulunmaktadır. Unsigned için direk özelleşmiş bir tür bulunmamaktadır. Bu nedenle bit seviyesinde işlem yaparken kullandığınız programlama dili, platform ve derleyici özelliklerine bakmakta fayda olacağını söyleyebiliriz. Diğer türlü sabit kabullerle hareket edilirse yanlış sonuçlarında elde edilebilme şansı olacaktır.Tabi akıllara burada şu soruda gelebilir. Bir tam sayıyı temsil etmek için neden bu kadar farklı tür mevcut ? Bunun içinde şöyle cevap vermek mümkün aslında sonuçta bu değerler gün sonunda bellekte yer kaplayacaklar ve bu bellek alanımızın bir boyutu var (2gb, 8gb vb.) dolayısıyla bu alanı verimli kullanmak bir sebep olmakla beraber, işlemcinin belirli tiplerde daha iyi performans göstermesi ve serileştirme süreçlerinide buna dahil edebiliriz. Aşağıda Java da türlerin kapladıkları bellek alanı ve değer aralıkları görülebilir. Yine istersek diğer diller içinde örneğin c için “c data types” şeklinde aramalar yaparak türler için belirtilmiş boyutlara erişilebilir. Tür Bellek Değer Aralığı byte 1 byte [-128 , 127] short 2 byte [-32,768 , 32,767] int 3 byte [-2,147,483,648 , 2,147,483,647] long 4 byte [-9,223,372,036,854,775,808 , 9,223,372,036,854,775,807] Ondalıklı Sayılar Bellekte Nasıl Temsil Edilir ?Ondalıklı sayılar bilgisayarda IEEE 754 standartına göre temsil edilirler. Burada sayılar genellikle 32 bit tek hassasiyetli ve 64 bit çift hassasiyetli olarak ele alınırlar.Bu stadartta sayılar 3 bölümde incelenir. Sign bit : Sayının pozitif negatifliğini saklar. Exponent : Sayının büyüklüğünü saklar. Mantissa : Sayının kesirli kısmını saklar.32 ve 64 bit için ilgili kısımlar için kullandığı bit sayıları aşağıdaki şekildedir.32-bit (float): 1 bit işaret (sign bit) 8 bit üstel kısım (exponent) 23 bit mantissa (fraction)64-bit (double): 1 bit işaret (sign bit) 11 bit üstel kısım (exponent) 52 bit mantissa (fraction)Programlama diline göre değişebilmekle birlikte genellikle 32 bit için float, 64 bit için double türlerinden yararlanılır. Yukarıda belirttiğim 3 kısmın detayları, normalization işlemi ve hesaplama yaklaşımları ile ilgili merakınız bulunuyor ise standardı okumanızı tavsiye ederim.String İfadeler Bellekte Nasıl Temsil Edilir ?Bilgisayarda her şeyin 0 ve 1’lerden oluştuğunu söylemiştik o nedenle bir string ifade de aslında gün sonunda bilgisayar için 0 ve 1’lerden oluşan bir sayıdan başka bir şey olmayacaktır. Tabi bu noktada bir kelimenin aslında harflerden oluştuğunu fark etmek gerekirki aslında hedefimizin ise bir karakteri veya harfi bilgisayarda temsil etmek için bir mantık oluşturabilmek olacaktır. Aynı mantıkla bilgisayarlı sistemlerin ilk günlerinden bugüne bu karakterleri temsil etmek için farklı standartlar oluşturulmuştur.Burada 2 terime dikkatinizi çekmek istiyorum. Karakter seti (Character Set) Kodlama (Encoding)Karakter Seti Nedir ?Karakter seti, bir dilde veya sistemde kullanılabilecek tüm karakterlerin bir koleksiyonudur. Yani, hangi karakterlerin mevcut olduğunu belirler. Özetle aslında karakter seti içerisinde hangi karakterler ve sembolleri temsil edebildiğini temsil eden dökümanlardır diyebiliriz.Kodlama Nedir ? Encoding veya kodlama, bir karakterlerin sayısal değerlere dönüştürülmesidir. Yani, her bir karakterin bellekte veya bir dosyada nasıl temsil edileceği ile ilgilidir. Bu temsil, karakterlerin sayısal (genellikle binary) bir formatta saklanmasını sağlar.Karakter setlerinden birkaçını inceleyecek olursak; ASCII (US-ASCII) karakter seti : Bilgiyarlı sistemlerin ilk günlerinde 2 bilgisayar arasında metin alışverişini standartize etmek amacıyla ASCII geliştirilmiştir. ASCII sistemi 7 bit temelinde karakter kümesini oturtmuştur. Dolayısıyla 7 bit ile encode edildiğinden 128 farklı karakter temsil edebilme şansı yakalamıştır. Fakat bu bir yere kadar yeterli gelirken bilgiyarlı sistemler hayatımıza girdikçe farklı ülkelerdeki insanlarında birbirleriyle iletişim kurduğu dünyada bu 128 karakter yetersiz hale gelmiştir. Çünkü diğer dillerde farklı karakterler mevcut ve artık 7 bit sınırları içinde bu yeni karakterleri ekleyecek bir sayı kalmamıştır. Bu karakter seti içerisinde türkçe karakterlerde bulunmamaktadır. (ş,ç,ğ,ü,ı içermez.) ASCII Extended (ISO 8859-1) karakter seti :ASCII’ nin yeni karakterler eklemekteki sıkıntılarını gidermek için 8 bit temelinde karakter setini oluşturmuştur. Bu da bu karakter setinde 256 karakter temsil şansı oluşturmuştur. İlk 128 karakteri direk standart ASCII dekileri baz almakla birlikte geriye 128 karakter temsil edilecek yeni alanlar oluşmuştur. Daha çok avrupa dillerine özgü karakterlere odaklanır. Burada bazı türkçe karakterler kendine yer bulmuştur fakat hala hepsini içermemektedir. (ı,ğ,İ içermez.)Süreç içerisinde yukarıda bahsettiklerimden farklı standartlarda oluşmuştur fakat şunu faketmeliyiz. 7 bit veya 8 bit ile encode edilsin sınırlarımızın mevcut olduğunu görmeliyiz. Max 256 karakter temsil edebiliyoruz. Ama düşününki Çin de kullanılan kanji karakterlerini sayısı bile 50 binleri bulmaktadır. Ve bunları bir byte gibi büyüklükte ifade etme şansımız olmayacaktır. O nedenle dünya üzerinde tüm karakterkeri kapsayan bir evrensel bir stadart üzerinde çalışılmış ve UNICODE standardı/karakter seti oluşturulmuştur. Bu standartın bilgisayarda temsil edebilmesi için UTF- şeklinde encode yapıları bulunmaktadır.Unicode AralıklarıUnicode karakter seti, farklı dil ve sembol gruplarını sınıflandırmak için bloklar kullanır. Her blok, belirli bir yazı sistemini veya sembol grubunu içerir. Latin harfleri (U+0000–U+007F) Yunanca (U+0370–U+03FF) Çin karakterleri (Han ideogramları) (U+4E00–U+9FFF) Matematiksel semboller (U+2200–U+22FF) Emoji (U+1F600–U+1F64F)UTF varyantları ve anlamları UTF-8 : Değişken uzunluktaki kodlamadır ve ASCII ile uyumludur. En yaygın kullanılan Unicode kodlama biçimidir. Karakterin durumuna göre 1 ila 4 byte arasında encode edilir. UTF-16 : Her karakteri 2 veya 4 baytla kodlar. Genellikle Batı dillerinde 2 bayt, diğer dillerde ise 4 bayt kullanılır. UTF-32 : Her karakteri 4 baytla kodlar. Bu, tüm karakterlere sabit uzunluk sağlar, ancak verimli değildir.Sonuç olarak baktığımızda Unicode, modern dijital dünyamızda metinleri standardize etmek için temel bir rol oynar ve dünya çapında 1 milyondan fazla karakteri destekler. Bu sayede, farklı dillerde yazılmış metinler, semboller ve özel karakterler arasında uyumsuzluk problemini ortadan kaldırmış olur. Bu kodlama biçimleri (UTF-) bellekteki temsildir. Ekranda karakter çizimleri söz konusu olduğunda bitmap (pixel matrisi) veya vector (harflerin sınırları ve eğrilerini tanımlayan matematiksel veriler) grafiklerden yararlanılmaktadır. Günümüzde bu işlemler genellikle font dosyaları (OpenType, TrueType) ile gerçekleştirilmektedir.Mojibake Nedir?Metinlerin yanlış karakterlerle, bozulmuş ve okunamaz şekilde görüntülenmesine verilen isimdir. Genellikle uyumsuz karakter kodlamasından kaynaklanır. Örnek vermek gerekirse UTF-8 ile kodlanmış bir metni Latin-1 gibi farklı bir karakter setiyle okunmaya çalışılırsa görünteleyemediği karakterler soru işareti veya farklı karakterler olarak görüntülenir. Şunu da belirtmekte fayda var, bu bir dönüştürme işlemi değildir. Yani herhangi bir veri kaybı oluşmaz sadece yanlış gösteriliyordur! Resmi inceleyelim.Utf-8 kodlama ile yazdığım metin.Aynı metni farklı bir kodlama biçimi ile görüntülemeye çalıştığımızda mojibake oluşmaktadır.Bit Manipulation (Manipülasyonu)Öncelikle bit manipulasyonuna geçmeden önce bilgisayarın 2’lik sistem üzerine kurulu olma sebeplerinden biriside boole cebri demiştik. Manipulasyonu anlayıp uygulayabilmemiz için bu cebri bilmemiz gerekir. Zaten sizlerde buralara kadar okumalar yapıyorsanız bu konuları çoktan biliyorsunuz demektir. Yine de hatırlatmak amacıyla bu cebrin kullanımıyla oluşturulan mantık kapılarını ve bu kapılar içerisinde yapabileceğimiz işlemler ve ulaşacağımız sonuçları inceleyelim.Ve(And) Kapısı : 2 veya daha fazla giriş üzerinde mantıksal işlemler yapılabilen mantık kapısıdır. Girişlerin tümü doğru olduğunda çıkış doğru olmakla diğer tüm durumlarda çıkış yanlıştır. &amp; (ampersand) işareti ile ifade edilir. Çarpma işlemi gibi davranır. a b a&amp;b = a*b gibidir 0 0 0 0 1 0 1 0 0 1 1 1 Veya(Or) Kapısı : 2 veya daha fazla giriş üzerinde mantıksal işlemler yapılabilen mantık kapısıdır. Girişlerden herhangi biri doğru olduğunda çıkış doğru olmakla diğer tüm durumlarda çıkış yanlıştır. | (pipe) işareti ile ifade edilir. Toplama işlemi gibi davranır. a b a|b = a+b gibidir 0 0 0 0 1 1 1 0 1 1 1 1 Özel Veya(Xor) Kapısı : 2 veya daha fazla giriş üzerinde mantıksal işlemler yapılabilen mantık kapısıdır. Girişlerden yalnızca biri doğru olduğunda çıkış doğru olmakla diğer tüm durumlarda çıkış yanlıştır. ^ (caret) işareti ile ifade edilir. a b a^b 0 0 0 0 1 1 1 0 1 1 1 0 Değil(Not) Kapısı : Tek giriş üzerinde mantıksal işlemler yapılabilen mantık kapısıdır. Verilen girişin tersini çıkışa verir. ~ (tilda) işareti ile ifade edilir. a ~a 0 1 1 0 Yukarıdaki kapılar kullanılarak farklı kapılarda elde edilebilir. Bunlar NAND, NOR, XNOR şeklindedir.Bu genel bilgiler sonrası şimdi gelelim artık manipulasyon konusuna burada şu soruların cevaplarını arayarak aslında manipulasyondan kastımız nedir ? Daha iyi anlayacağız. Bir sayının pozitifliği ve negatifliği nasıl tespit edilir ? Left/Right Shifting nedir ? Tek bir biti set/clear ve toogle olarak nasıl kullanabiliriz ? Bir sayıda kaç tane 1 bit bulunduğunu nasıl hesaplayabiliriz ?Örn : İşlemlerimizi basit olması amacıyla 8 bit ile gerçekleştireceğiz. 8 bitten büyük yapılarda da aynı şekilde bu bilgiler geçerli olacaktır. O konuda hani bir düşünceniz oluşursa siz sormadan ben söylemiş olayım :)Bir Sayının Pozitifliği Veya Negatifliği Nasıl Tespit Edilir ?Pozitiflik ve negatiflik kavramları signed türlerde geçerli olmakla beraber (unsigned ise zaten hep pozitiftir :) en yüksek bit(msb/sign) üzerinden hesaplanmaktadır. En yüksek bit 0 ise sayı pozitif, 1 ise negatif kabul edilir.Bir örnek üzerinden ilerleyelim. 5 sayısının 8 bitte temsili 0000 0101 şeklindedir. Peki -5 nedir ve nasıl hesaplanır ? Bu noktada 2’ye tümleyen kavramı ortaya çıkıyor. Bilgisayarda sayının negatif ifadesini tespit etmek için 2’ye tümleyen yöntemi kullanılır.2’ye tümleyenle bağlantılı olduğu için öncelikle 1’e tümleyeni inceleyelim çünkü birbiri ile bağlantısı bulunuyor. Bire Tümleyen Nedir ?Aslında değili (~) gibi düşünülebilir. 1’e tümlemek demek 0 ları 1’e 1’leri 0’a çevirme işlemidir. İkiye Tümleyen Nedir ?2’ye tümleme işlemi 1’e tümleme işleminin sonucuna +1 eklenmesi ile ifade edilir. Şimdi bu bilgiler doğrultusunda az önce sorduğumuz soruya dönelim -5 sayısını nasıl hesaplarız ?Sayımızı +5 olarak yazıp sonrasında 1’tümleyen alıp +1 ile toplarsak -5 i elde ederiz. Açıklama Temsili 7.bit 6.bit 5.bit 4.bit 3.bit 2.bit 1.bit 0.bit +5’in 8 bit gösterimi x 0 0 0 0 0 1 0 1 +5’in 1’e tümleyeni ~x 1 1 1 1 1 0 1 0 +1’in 8 bit gösterimi y 0 0 0 0 0 0 0 1 -5’in 8 bit gösterimi ~x + y 1 1 1 1 1 0 1 1 Tabloyu incelerken 7. bitimizin işaret(sign) biti olduğunu unutmayalım. Burada çok önemli 4 nokta olduğunu düşünüyorum.1.Nokta: Bir sayının unsigned ile temsil edilmesiyle signed temsil edilmesi alabileceği değer aralığını da etkiliyor. Çünkü unsigned la temsilde iken en yüksek yani sign bitimiz normal işleme dahil edilirken signed temsilde ise o bit işaret için kulanıldığından otomatikmen alabileceği değerler kısıtlanıyor.Hemen bir örnek üzerinden bakalım. unsigned short = 1111 1111 ise değerimiz 255 i ifade ederken signed short = 1111 1111 ise değerimiz sayı signed temsil edildiği için yine 2’ye tümleyen kullanarak orjinaline dönüp bulabiliriz. İlgili işlemi uzunca yapmayacağım. Yukarıda örneklemiştik zaten. 2’ye tümlediğimizde 0000 0001 olur yani sayımız -1 imiş.Fikir edinmek açısından aşağıdaki -5 ile +5 aralığını tablodan gözlemleyelim. Sayı 8 Bit İfade -128 1000 0000 -5 1111 1011 -4 1111 1100 -3 1111 1101 -2 1111 1110 -1 1111 1111 0 0000 0000 +1 0000 0001 +2 0000 0010 +3 0000 0011 +4 0000 0100 +5 0000 0101 +127 0111 1111 Buradan da net görebiliyoruz en yüksek bit işaret olunca elimde kullanabileceğim geriye 7 bit kalıyor ve en yüksek sayı için hepsini bir yaparsam 0111 1111 olurki bu da 127’ye denk geliyor. Ama işaretsiz bir tür olsaydı hepsi bir olabiliyordu 1111 1111 o zaman en yüksek 255 olabilirdi. Dolayısıyla aslında yarı yarıya ifade edeceğim sayı aralığı azalıyor.Şöyle özet şeklinde gösterelim. 8 bit unsigned alabileceği değer aralığı -&gt; [0,255] 8 bit signed alabileceği değer aralığı -&gt; [-128,127]2.Nokta: ise taşma(overflow) davranışı. Temsil türümüz signed iken en küçük sayıdan 1 çıkarınca pozitif en büyük sayıyı, en büyük pozitif sayıya 1 ekleyince en küçük negatif sayıyı buluruz. Bunun sebebini hemen farkedeceğinizi düşünüyorum çünkü toplama sonucu işaret bitini tersine çevirmiş oluyor. Ve bunun vaktiyle sorununu PSY nin Gangnam Style şarkısı Youtube da izlenme sayısı veri türü değer aralığını (signed 4 byte) aşınca yaşanmıştı ve izlenme sayısı negatife dönüşmüştü.3.Nokta: Bir signed türünde pozitif sayının 2’ye tümleyenini alınca o sayının negatifini, tekrar 2’ye tümleyenini alınca ise pozitifini elde ederiz. Aslında matematikteki tersinin tersi kendisidir durumunu ifade eder. Açıklama Temsili 7.bit 6.bit 5.bit 4.bit 3.bit 2.bit 1.bit 0.bit +5’in 8 bit gösterimi x 0 0 0 0 0 1 0 1 +5’in 2’ye tümleyeni(-5) ~x + 1 1 1 1 1 1 0 1 1 -5’in 2’ye tümleyeni(+5) ~(~x + 1)+1 0 0 0 0 0 1 0 1 4.Nokta: Son olarak Sign Extension (işaret genişletme) kavramından da bahsetmiş olayım. Şimdi biz 8 bitlik örnekler yaptığımız için pek ortaya çıkmadı ama aynı 8 bitlik sayımızı 32 bit bir signed türde saklasaydık. O zaman sayımızın işaret bitinden sayımıza kadar tüm bitler aynı değeri alırdı. Yani negatifse işaret bitinden sayıya kadar 1, pozitifse işaret bitinden sayıya kadar 0 olur. Buradaki amaç sayının işaretini ve değerini korumaktır. Aşağıdaki resme bakarsanız Java da -7 sayısını byte bir türde ve int bir türde sakladığımızda binary yani 2 ‘li olarak gözlemlediğimizde ne demek istediğimi daha rahat anlayabilirsiniz.Left/Right Shifting Nedir ?Shifting kavramı aslında ilgili ifadenin bitlerinin sağa veya sola kaydırma işlemidir.Sola kaydırma için « işareti kullanılırken sağa kaydırma yapmak için » işareti kullanılır.Kullanım şekli : (neyi « ne kadar kaydıracağız) gibi düşünebiliriz. Sayımız x=106 olduğunu varsayarsak örneğin x’i 2 birim sola kaydırmak istiyorsam nasıl yazarım. x«2 şeklinde veya x’i 5 birim sağa kaydırmak istiyorsam x»5 şeklinde ifade ederim.Peki x’i 3 birim sola kaydırınca yani x«3 yapınca ne olur ?Öncelikle resmi dikkatlice incelemeye çalışalım. Burada şunu farketmemiz önemli 3 bit sola kaydırınca 8 bit kullandığımız için son yer aslında 7.bit olduğundan 4. biti 3 kaydırınca 7.bite denk gelir. Ve bu da 4 ten sonraki bitler kaydırılınca taşma yaratacağı için silineceği (resimdeki turuncu kutular) anlamına gelir. O nedenle eğer 4. bitten sonra değerli verilerimiz var ise bu noktada kaybederiz. Bizimde x sayımızda aslında 6. ve 7. bitlerde 1 ler bulunuyordu dolayısıyla bu kaydırma sonrası onları kaybedeceğiz. Bir diğer durumda sola kaydığımız için sağdan eksilen yerler için 0 eklenir (resimdeki mavi kutular). x başlangıçta 106 iken kaydırma sonrası 80 değerini almıştır. Eğer taşma olmadan kaydırma gerçekleştirseydik ki bunu başarmak için sadece 1 kaydırmamız lazım çünkü 8 bit kullanıyoruz. O nedenle solda anlamsız tek 0 olan bit 7.bitte olduğu için 2 kaydırdığımız anda 6. biti de kaybederiz. Eğer başangıçta x 8 bit bir sayı değilde 32 bit deseydik o zaman problem oluşmazdı. Çalıştığımız bit sayısına göre taşma sınırlarımızın değişeceğine dikkat edin! O nedenle bu verilen örnekte taşma olmadan sola kaydırma için tek seçenek 1 kaydırmaktır. Ve eğer x«1 yaparsak sürpriz! Sayımız 2 ile çarpılmış olur. Yani sonuç artık 212 dir.Yine x in orjinal halini yani 106 formunu sağa kaydırırsak ise 2’ye bölme gerçekleşir. Ve sonucumuz 53 olur. Tabi bu bölmeyi de görebilmek için sadece 1 kaydırmamız gerekir çünkü sağda anlamsız olan 0 sadece 0.bit te dolayısıyla 1 den fazla sağa kaydırdığımız anda kayıplar yaşamaya başlayacağız. Yine burada da solun tersi prensip olacak yani sağa kaydıkça sağdan bitler silinecek sola 0 lar eklenecektir. x’i 1 birim sağa kaydırdığımızı düşünelim. Sonuç için resmi inceleyelim.x»2 ve daha fazlasını da deneyerek nasıl kayıplar yaşadığımızı sizlerde uygulayarak gözlemlemeye çalışın. 2’lik sistemde olduğumuzdan kaydırma işlemlerinde veri kaybetmediğimiz sürece sola kaydırmanın 2 ile çarpma, sağa kaydırmanın ise 2 ile bölme işlemi olduğuna dikkat edin. Ayrıca şunu da bilmekte fayda var. Kaydırma ile bölme işlemi gerçekleştirmek tam sayı bazında olacaktır. Yani 3 ü bir sağa kaydırınca 1,5 değil 1 elde ederiz! Bu da kaydırma işleminin kesirli kısmı görmezden geldiğini gösterir. Dolayısıyla kesirli bölme ihtiyacınız var ise normal bölme işlemi uygulamalısınız.Tek Bir Biti Set/Clear ve Toggle Olarak Nasıl Kullanabiliriz ?Sayımızdaki 0 olan bir biti 1 yapmak veya tam tersi 1 olan bir biti 0 yapmak istediğimizi düşünelim. Burada maske kavramı ortaya çıkıyor. Maske aslında bit düzeyinde yapmak istediğim işlemimi karşılayacak bir 2’li ifadeyi temsil ediyor. Sonrasında bu maske ile orijinal sayımızı bitsel işlemlere tabi tuttuğunuzda istediğimizi aslında elde edebiliyoruz. İlk olarak bir biti 0 setleme işlemine bir bakalım. Bunun için aşağıki resmin adımlarını sırasıyla inceleyelim (Adımlar anlaşılsın diye fazlaca detaylandırdım aslında tek satırda bile halledilebilir). Burada maske için 1 sayısından yararlanıyoruz (resimdeki 1.adım). Peki neden 1 sayısı dersek. 1 sayısının binary karşılığı nedir ? 8 bit olarak düşünürsek 00000001b dir. Yani tek bir tane 1 değeri var ve benimde hedefim zaten bir bit e müdahale etmek. O nedenle maskelerimizi oluşturmak için tam bir biçilmiş kaftan diyebiliriz.Hedefimiz x=106 sayısının 5. bitini 0’a setlemek olduğunu düşünürsek. Öncelikle 1 sayısını 5 birim sola kaydırıyorum ki tam müdahale edeceğim bit ile çakışsın (resimdeki 2.adım). Yani artık maskemiz 00100000b oldu. Sonrasında 0’ a setlemek istediğim için bu kaydırma işlemi sonrası yeni değerin tersini alıyorum. (resimdeki 3.adım) Artık maskemiz 1101111b oldu. Neden tersini aldık ? Çünkü bir biti 0 yapmak için &amp; (ve) işleminden yararlanacağım. Bildiğiniz üzere ve kapısı sadece tüm girişler 1 iken çıkışa 1 veriyordu diğer tüm durumlarda çıkış sıfırdı. Bizde bu özellikten yararlanarak sadece istediğim biti 0 diğer kalan bitlerinde mevcuttaki halini koruması için bu şekilde bir işlem gerçekleştiriyoruz. Aski halde tersini almasaydık ne olurdu ? İsterseniz bunu bir düşünün !Kısaca bir biti 0 yapmak istiyorsak şöyle formulleştirebiliriz. public static void main(String[] args) { // Formül : sayimiz &amp;= ~(1&lt;&lt;sıfır yapmak istediğim bit) byte x = 0b00100111; byte mask = ~(1 &lt;&lt; 2); // 2.biti 0 yapmak istiyorum. byte result = (byte) (x &amp; mask);}Peki diğer durumu inceleyim. Yani bir biti 1 yapmak istiyorsak peki? Bu sefer aslında yine 1 sayısını kullanarak maskemizi oluşturacağız. Fakat sonrasında bu sefer ve kapısını değil veya kapısını kullanacağız. Neden ? Çünkü bu kapıda girişlerden herhangi biri 1 olsa çıkış 1 oluyordu bizimde hedefimiz zaten 0 olan bir biti 1 yapmak ve aynı zamanda mevcuttakileri de korumak olduğundan direk bu kapı istediğimizi bize sağlayabiliyor.Hedefimiz x=106 sayısının 4. bitini 1 yapmak olduğunu düşünelim ve resmi inceleyelim. Artık detaylandırmaya gerek yok sanırım zaten anladınız :)public static void main(String[] args) { // Formül : sayimiz |= (1&lt;&lt;bir yapmak istediğim bit) byte x = 0b00100111; byte mask = (byte) (1 &lt;&lt; 7); // 7.biti 1 yapmak istiyorum. byte result = (byte) (x | mask);}Peki bu 2 operasyonu birleştirsek yani aynı işlemi tekrar tekrar yaptığımızda farklı sonuçlar alsak. Sanki bir aç/kapa anahtar gibi. Yani açıksa kapansa, kapalıysa açılsa. Bu da aslında toggle ı ifade ediyor. Bunun için ise xor kapısından yararlanıyorum. Neydi hatırlayalım. Girişlerinden sadece birisi 1 iken çıkışa 1 veriyordu. Dolayısıyla bu davranışı kullanırsak, yine başlangıçta 1 maskesi oluşturacağız ve hangi bite bu davranışı uygulayacak isek maskemizi o konuma göre kaydıracağız.Örneğin 2. biti aç kapa yapmak istiyoruz. Yapmam gereken yine 1 maskemi o pozisyona getirip xor işlemine tabi tutmak. Bu durumda o konumdaki bit 0 ise 1, 1 ise 0 olur. Yani aslında aç/kapa davranışını simule etmiş oluruz.Aşağıdaki kod parçasını dikkatlice inceleyelim. Biraz daha komplex bir örnek göstermek istedim. Sade bir bitle uğraşmakta istemiyor olabiliriz. Bu kısımlarda hep düşünmenizi tavsiye ederim. Ancak o zaman aslında nerelerde işinize yarar ? Ve sizin için anlamlı olur daha iyi anlarsınız.public static void main(String[] args) { // Formül : sayimiz ^= (1&lt;&lt;toggle olarak kullanmak istediğim bit) byte x = 0b00000000; byte mask_FirstBit = (1 &lt;&lt; 1); // 1.biti toggle olarak kullanmak istiyorum. byte mask_FifthBit = (1 &lt;&lt; 3); // 3.biti toggle olarak kullanmak istiyorum. byte mask_Seventh = (1 &lt;&lt; 5); // 5.biti toggle olarak kullanmak istiyorum. byte all_mask = (byte) (mask_FirstBit | mask_FifthBit | mask_Seventh); x = (byte) (x ^ all_mask); //1,3,5. bitler açıldı x = (byte) (x ^ all_mask); //1,3,5. bitler kapandı x = (byte) (x ^ all_mask); //1,3,5. bitler açıldı x = (byte) (x ^ all_mask); //1,3,5. bitler kapandı}Bu yapısından ötürü xor şifreleme yöntemlerinde de oldukça sık kullanılmaktadır!Bir Sayıda Kaç Tane 1 Bit Bulunduğunu Nasıl Hesaplayabiliriz ?Bu güzel bir soru arkadaşlar, çözüme geçmeden önce sizde kendinizi bir sınayın derim. Ve sonrasında çözümü görünce vay be deyip bir aydınlanma yaşayabilirsiniz.Şimdi aşağıdaki çözümde kullandığım yöntemi biraz açıklayalım. Bu işlemi yapabilmek için yine bir maskeye ihtiyacımız olacak. Açık olarak mask diye bir değişken tanımlamasakta artık bunu direk farkedeceğinizi düşünüyorum. Bu noktada yine genel olarak yararlandığımız 1 maskesinden yararlanacağız. Yani 8 bit olarak düşünürsek 0000 0001. Sonrasında şunu düşünüyoruz. Sayı içindeki 1 olan bitleri bulmak istediğimizden her biti bireysel olarak maskemle bir işleme tabi tutmalıyım ve sonuçtan sayıdaki ilgili bitin 1 olduğunu anlayabileyim. Bu noktada aklımıza ve kapısı geliyor. Ve kapısının anlamı neydi ? Tüm girişler yani bizim durumumuzda 2 girişte 1 olursa ancak çıkış bir oluyordu. Dolayısıyla bu kapının özelliğinden yararlanarak 1 maskesi ile sayımızı (yani x i) &amp; işlemine tabi tutuyorum. Peki sonuç ne çıkar bu işlemden ancak sayımdaki maskeyle eşleşen bit 1 ise 1 yoksa 0 olacaktır. Aslına bakarsak o konumdaki bitin 1 olduğunu bu şekilde anladık. Peki sayının diğer bitlerine nasıl bakacağız dersek ? Burada farklı teknikler olabilmekle beraber tabi her yönteminde kendine göre bir performans durumu olacaktır. Aklınıza maskeyi kaydırmak gelebilir evet doğrudur fakat her bite bakmak daha fazla işlem adımına sahip olacaktır. O nedenle maskeyi sabit tutup sayıyı kaydırıyoruz! Koda dikkat ederseniz her &amp; (ve) işleminde o anki biti kontrol ediyoruz ve sonraki bite geçmek için ise sayıyı 1 bit sağa kaydırıyoruz. Bu şekilde sayının içindeki 1 bitler bitene kadar sürekli sağa kayma yapacak ve sonunda x sayısı 0000 0000 olacak ve artık while döngüsüne girme şansı yakalayamayacak (x&gt;0 koşulu var, dikkat edin). Sonrasında artık one_count değişkeni içerisinde x sayısında kaç tane 1 bit olduğunu bulmuş olağız. Bizim örneğimizde 3 tane olduğundan sonucumuz 3 çıkacaktır.public static void main(String[] args) { byte x = 0b01001010; byte one_count = 0; while (x &gt; 0) { one_count += (byte) (x &amp; 1); //sayımla maskeyi ve işlemine tabi tutuyorum! x &gt;&gt;= 1; //sayının diğer bitini kontrol e tabi tutmak için 1 bit sağa kaydırıyorum! } System.out.println(one_count); // 3 basar.}Bu çözümden daha performanslısı var mıdır acaba diyenler için Brian Kernighan Algoritmasını, incelemelerini tavsiye ederim.Endiannes Nedir ?Son olarak bu kavramada değinmeden yazıyı sonlandırmak istenmedim. Yaptığımız örnekler daha iyi anlaşılsın diye genelde örnekleri 8 bit olarak göstermeye çalıştım. Fakat sizlerinde bildiği gibi bilgisayardaki türlerimiz hep 8 bit değil, daha çok bu 8 bit gruplarının biraraya gelerek oluşturduğu türlerdir. Peki bellekteki en küçük adreslenir alanında 8 bit yani 1 byte olduğunu biliyorsak. O zaman elimizdeki 8 bitten büyük ifadeleri bu belleğe nasıl yerleştirmeliyim ? Bunun için 2 yaklaşım karşımıza çıkıyor. Little Endian (LE) : En önemsiz baytın en düşük bellek adresinde depolanması Big Endian (BE) : En önemli baytın en düşük bellek adresinde depolanmasıHemen yine bir örnek üzerinden gidecek olursak. Elimizde int x = 1.791.791.791 ifadesi olduğunu düşünelim. Bunun 2’lik karşılığı nedir ? 01101010110011001001001010101111. Peki bunu belleğe nasıl yerleştirelimki tekrar ihtiyacım olduğunda da aynı düzende okuyup birleştirerek bu sakladığım değere ulaşayım.Diğer bir hususta bunun ne gibi kullanımı var diyebiliriz ? Aslında bu kavram çok değerli çünkü eğer ağ tabanlı işler veya veri transferi gibi işlemler gerçekleştiriyorsak. Endian durumunu bilmeliyimki veriyi doğru şekilde ulaşayım. Yoksa anlamsız verilerle karşılabiliriz.Bazı önemli bilgiler : Ağ protokolleri genel olarak Big Endian düzende sıralama kullanmaktadır. O nedenle aslında Big-Endian a ağ sıralamasıda denilebilmektedir. İşlemciler x86 tabanlılar Little Endian sırası kullanmakla birlikte bazı işlemciler ikisini birden destekleyebilir. Programlama dilleride genellikle işlemci endianness’ine uyar.O nedenle little endian bir işlemci düzeninde network operasyonu yapınca, ağa giderken big endian, ağdan veri alınca little endian düzenleri arasında dönüşüm gerçekleşir.SonuçBir yazının daha sonunda geldiğimiz bu noktada şöyle bir özet geçecek olursak öncelikle bilgisayarın 2’li sistemi kullanma gerekçesinden başlayıp sonrasında tam sayı, ondalıklı sayı, metinsel ifadeler gibi farklı veri türlerini bilgisayarların nasıl ele aldığını inceledik. Özellikle metinsel ifadelerdeki tarihsel süreçteki karakter setleri ve encode(kodlama) türlerini, yine yanlış kodlama türüne bağlı gösterim sonucunda doğan mojibake kavramından bahsettik. Devamında ise bu bit dünyasında oluşturulan logic gate (mantık kapıları) lere ve bitleri manipule ederek neler yapabileceğimize değindik. Son kısımda ise elimizde bu kadar bit varken bunları nasıl bir düzende sıralamalıyız ki veriler anlamını yitirmesin deyip endiannes kavramını irdeledik ve yazımızı sonlandırdık. Umarım bu okuma sonucunda sizlerde bilgisayar dünyasının bitler ve bu bitleri manipule etmekle alakalı olduğunu farketmişsinizdir. Günlük hayatımızda böyle değil mi ? Aynı elektrik buzdolabını soğuturken, fırını ısıtıyor. Aslında buradan bakarsak her şey hayal gücünüzle sınırlı. O nedenle manipule etmekten çekinmeyin.Hepinize bol manipulasyonlu kodlamalar :)" }, { "title": "Java Syntactic Sugar (Söz Dizimsel Şeker)", "url": "/posts/java-syntactic-sugar/", "categories": "Programlama, Java", "tags": "java, syntax, syntactic sugar, söz dizimsel şeker, programlama", "date": "2021-01-03 11:13:00 +0300", "snippet": "Java Syntactic Sugar (Söz dizimsel şeker) Nedir?Bir programlama dilinde söz dizimsel şeker, programcının işini kolaylaştıran kullanışlı bir söz dizimi olarak tanımlanabilir. Aşağıdaki farklı yapılarda kullanabildiğimiz söz dizimsel şekerleri inceleyeceğiz ve çoktan birçoğunu ismini bilmeden kullandığınızı farkedeceksiniz. Örnekleri JAVA üzerinden incelesekte birçok dil bu söz dizimsel şekerlere sahiptir.Increment/DecrementToplama, çıkarma, çarpma vb. birçok işlem sonrası atama yaptığımız standart söz dizimini, söz dizimsel şeker sayesinde daha sade bir şekilde kullanabiliriz.public static void incrementDecrementSyntaxSugar() { int i; i = i + 1; //standart i += 1; //syntax sugar}Burada i++ ile bu durumu karıştırmayın. i++ (post increment) operatorudur. Bu operator ifade edildiği satırda önce mevcutu ilgili değere atayıp sonra değeri arttırmaya yönelik bir yol izler.public static void postIncrement() { int i = 2; int x = i++; //burada x ve i 2 olacaktır. //bu satırda artık i 3'tür.}If-Else StatementSıklıkla kullandığımız karşılaştırma ifademiz olan if-else yapısını söz dizimsel şekerli hali olan ternary karşılaştırma olarak tek satırda kullanma şansı yakalayabiliriz.public static void ifElseStandart(int peopleCount) { //standart if (peopleCount &gt;= 2) { System.out.println(\"Count 2 veya 2 den büyük.\"); } else { System.out.println(\"Count 2 den küçük.\"); }}// Söz dizimi : koşul ? doğru ise bu kısım : yanlış ise bu kısım;public static void ifElseSyntaxSugar(int peopleCount) { //syntax sugar System.out.println(peopleCount &gt;= 2 ? \"Count 2 veya 2 den büyük.\" : \"Count 2 den küçük.\"); // ternary condition olarakta adlandırılır.}For LoopDöngülerde de yine sıklıkla el alışkanlığı ile standart for yazma eğilimi gösterebiliriz. Fakat eğer indisler üzerinde bir işlem gerçekleştirmeyip sadece okuma(read) işlemi gerçekleştirecek isek hiç indise girmeden söz dizimsel şekerli hali foreach i kullanabiliriz.public static void forLoopStandart() { //standart int[] numbers = {1, 2, 3, 4, 5}; for (int i = 0; i &lt; numbers.length; i++) { System.out.println(numbers[i]); }}public static void forLoopSyntaxSugar() { //syntax sugar int[] numbers = {1, 2, 3, 4, 5}; for (int number : numbers) { //foreach döngüsü olarakta adlandırılır. Ve dizinin uzunluğuna gerek kalmadan iterasyonu kolayca yapabiliriz. System.out.println(number); }}String ConcatenationÇoğu durumda string birleştirme işlemi yaptığımız senaryolarla karşılaşabiliyoruz ve bu gibi durumlarda ilk akla gelen string ifadeleri toplamak(+) yönünde olabiliyor. Kısa metinlerde belki bu işimizi görebiliyor fakat metnimiz biraz uzunsa ve harici parametrelerle desteklenmek istendiğinde metin biranda + işaretleri içerisinde yüzmeye başlıyor ve hataya açık bir hale gelebiliyor. Bu noktada yine söz dizimsel şeker olarak kabul edebileceğimiz format kullanımı ile daha temiz bir görünüme kavuşabiliriz.public static void stringConcatStandart(String whoami, int times) { //standart String message = \"Ben bir \" + whoami + \"im. Ve \" + times + \" kez ders verdim.\"; System.out.println(message);}public static void stringConcatSyntaxSugar(String whoami, int times) { //syntax sugar String message = String.format(\"Ben bir %sim. Ve %d kez ders verdim.\", whoami, times); System.out.println(message);}Burada akla StringBuilder yapısada gelebilir fakat bu yapı görünümden ziyade daha çok ifadeyi manipule etmeyi ve performansı iyileştirmeyi hedefler.Try - CatchJava 7 ile gelen try-with-resources, otomatik kaynak yönetimi (özellikle dosya işlemleri) için kullanılır ve koda daha temiz bir görünüm katar. Aşağıda da görebileceğimiz gibi standart kullanımda finally bloğunda okuma işlemi yapan kaynağımızı kapatmamız(close) gerekirken, diğer kullanımda bu bloğu hiç eklemeden hem kaynağı kapatmayı unutma durumunu ortadan kaldırıyoruz hem de daha sade bir görünüm elde ediyoruz.public static void tryFinallyStandart() throws IOException { //standart BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(\"file.txt\")); //Dosya işlemleri } catch (FileNotFoundException e) { e.printStackTrace(); } finally { if (reader != null) { reader.close(); } }}public static void tryFinallySyntaxSugar() throws IOException { //syntax sugar try (BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"))) { //Dosya işlemleri } catch (FileNotFoundException e) { e.printStackTrace(); }}LambdaJava 8 ile gelen lambda ifadeleri, özellikle koleksiyonlar üzerinde işlem yaparken daha kısa ve anlaşılır kodlar yazılmasını sağlar. Aşağıdaki örnekte bir koleksiyonu sıralamak istiyoruz ve bunun için Collection.sort tan yararlanıyoruz. Sıralama işlemini hangi şarta göre yapacağını anlayabilmek için 2. parametre olarak bir karşılaştırıcı(comparator) beklemektedir. Örneğimizde bu parametre anonim sınıf yardımı ile geçilmiştir. Ve koda göz korkutucu bir hava katmıştır. Aynı yapıyı söz dizimsel şeker kabul edebileceğimiz lambda ile ifade edince bu havanın nasılda dağıldığını hemen görebiliriz.public static void lambdaStandart() { //standart List&lt;String&gt; names = Arrays.asList(\"Victoria\", \"Alice\", \"Bella\"); Collections.sort(names, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o1.compareTo(o2); } }); names.forEach(System.out::println);}public static void lambdaSyntaxSugar() { //syntax sugar List&lt;String&gt; names = Arrays.asList(\"Victoria\", \"Alice\", \"Bella\"); Collections.sort(names, (o1, o2) -&gt; o1.compareTo(o2)); names.forEach(System.out::println);}Lambda Method ReferenceLambda ifadeleri için ok(-&gt;) işaretlerinden yararlanmaktayız. Bunlardan kurtulup daha sade bir görünüme kavuşmak için method referanslı halini kullanabiliriz.public static void lambdaMethodReferenceStandart() { //standart List&lt;String&gt; names = Arrays.asList(\"Victoria\", \"Alice\", \"Bella\"); names.forEach(name -&gt; System.out.println(name));}public static void lambdaMethodReferenceSyntaxSugar() { //syntax sugar List&lt;String&gt; names = Arrays.asList(\"Victoria\", \"Alice\", \"Bella\"); names.forEach(System.out::println);}Risk Her şeyin fazlasının zarar olduğunu bilip aşırıya kaçarak daha okunur olmasını beklerken daha okunamaz hale getirmeyelim. Aşağıda iç içe ternary ler kullanıldığında okunurluğun nasıl düştüğünü görebilirsiniz. Yine benzer şekilde diğer kullanımlarında da bunları gözeterek kullanmak bizler için daha yararlı olacaktır.public static void lowReadable() { //okunurluk düşük int a = 10, b = 20, c = 30; String result = (a &gt; b) ? ((a &gt; c) ? \"a is greatest\" : \"c is greatest\") : ((b &gt; c) ? \"b is greatest\" : \"c is greatest\"); System.out.println(result);}public static void highReadable() { //okunurluk yüksek int a = 10, b = 20, c = 30; String result; if (a &gt; b &amp;&amp; a &gt; c) { result = \"a is greatest\"; } else if (b &gt; c) { result = \"b is greatest\"; } else { result = \"c is greatest\"; } System.out.println(result);}SonuçSöz dizimsel şeker geliştiren kişiye daha az kod yazma, kodu daha okunabilir ve bakımı daha kolay hale getirme imkanı tanır. Ancak risk kısmında da bahsettiğimiz gibi kaş yaparken de göz çıkarmamaya dikkat etmemiz gerekir. Son olarakta unutulmamalıdır ki bu özellikler yalnızca yazım kolaylığı sağlamaktadır, dilin performansını ya da davranışını değiştirmemektedir." }, { "title": "Jump Search (Atlamalı Arama)", "url": "/posts/jump-search/", "categories": "Algoritmalar, Arama Algoritmaları", "tags": "c#, arama algoritmaları, jump search, sıralı arama varyant, doğrusal arama varyant, atlamalı arama", "date": "2020-03-07 11:22:00 +0300", "snippet": "Jump Search (Atlamalı Arama) Nedir ?Atlamalı arama algoritması aslında bir nevi linear search varyantı desek yanlış olmaz sanırım. Çünkü algoritma aslında linear search teki karşılaştırma miktarını azaltarak zaman karmaşıklığını düşürmeyi sağlar. Tabi her avantaj kendince bir dezavantajı beraberinde getireceğinden burada da linear search ten farklılaşarak sıralı koleksiyonlar ile çalışmak zorunda kalır. Bu sebeple sırasız koleksiyonların daha önce sıralanmadan jump search ü uygulaması mümkün olmaz.Algoritmanın Kodupublic static bool jumpSearch(int[] arr, int val) { int blockSize = (int)Math.Sqrt(arr.Length); int startIndex = 0; int endIndex = blockSize; while (endIndex &lt; arr.Length &amp;&amp; arr[endIndex] &lt; val) //aradığı değerin bulunduğunu düşündüğü bloğun tespiti { startIndex = endIndex; endIndex += blockSize; } if (endIndex &gt;= arr.Length) // blok sınırının taşıp IndexOutOfBound ihtimaline karşı, sınırın son index e çekilmesi { endIndex = arr.Length - 1; } for (int i = startIndex; i &lt;= endIndex; i++) // linear search yapıldığı nokta { if (arr[i] == val) { return true; } } return false;}Nasıl Çalışır ?Algoritma, koleksiyonun blok blok şeklinde olduğunu düşünerek hareket eder. Dolayısıyla aradığı eleman bu bloklardan birindedir veya hiçbirinde değildir yani bu koleksiyonda yoktur kanısına varır. Blokları kontrol ederken aradığı elemanın ilgili blokta olduğuna inandığı noktada linear search gerçekleştirir. Bu noktada bulabilirse buldu yoksa aradığı eleman bu koleksiyonda bulunmuyor şeklinde bir sonuca ulaşılır.Algoritmanın DavranışıKoleksiyonumuzun aşağıdaki gibi olduğunu düşünelim ve 91 değerini aradığımızı varsayalım.Block size hesabıAlgoritmanın ilk yaptığı şey bir block size hesaplamak olacaktır. Yukarıda da bahsettiğim gibi aslında bu değer koleksiyonun kaç bloktan oluştuğunu temsil eder. Bu hesabı yapmak için koleksiyonun eleman sayısının karekökünü alır. Neden karekök ? Çünkü çok uzun atlayışlar yaparsam aradığım değeri aşabiliriz ve geri dönmemiz gerekebilir, çok kısa atlayışlar yaparsamda normal linear search e yakınsarız ve bu aramanın pek bir anlamı kalmaz. Küçük bir matematik ile √n nin uygunluğunu anlayabiliriz. Koleksiyonumuzun n boyutlu oludğunu ve atlama miktarımızın(block size) x olduğunu düşünelim. En kötü durum senaryosunda yani son bloğun sonuncu index indeki değeri aradığımızı varsayalım. Bizim 91’i aradığımız gibi. Bu durumda n/x atlama yaparız. Ve sonrasında linear search içinde x-1 karşılaştırma gerçekleştiririz. Sonuç olarak total miktar = n/x + x-1 yapar. Bu kısmı 0 a eşitleyip x’ e göre türev alırsak.d/dx (n/x + x-1) = -n/x^2 + 1 = 0x = √n olarak tespit etmiş oluruz. Bu da en kötü durumda en optimum miktarın √n olduğunu gösterir.İlgili blok tespitiBlock size hesaplandıktan sonra resme dikkatli bakarsanız ilgili bloğu bulmak için 3 kez while döngüsü çalışıyor ve aradığı değerin bulunduğunu düşündüğü(endIndex teki değerin aradığı değerden büyük olduğu veya koleksiyon sınırlarını aşarsa döngüden çıkıyor). Bu noktada neden sıralı koleksiyonlarda çalıştığını fark etmiş olmalısınız. Hatta farkedemediyseniz birkaç dakika bu noktada düşünmenizi tavsiye ederim.Taşma kontroluBu kısım aslında algoritmanın uygulanış şekline göre değişkenlik gösterebilir, sizlerde internette farklı kaynaklardan araştırmalar yaptığınızda farklı varyantları ile karşılabilirsiniz. Fakat buradaki uyguladığımız şekliyle endIndex imizin koleksiyon sınırını geçip geçmediğine bakıyoruz. Eğer sınırı geçmiş ise koleksiyonumuzun son index ine konuşlandırıyoruz. Neden son index? Çünkü zaten sınır dışına çıkmış bir index bizim koleksiyonumuzda bakabileceğimiz bir konum değildir. O nedenle koleksiyonumuzda aradığımız değeri bulabileceğimiz son konumu yani son index i atıyoruz.Ayrıca bu şekilde olası IndexOutOfBound hatasınında önüne geçmiş oluyoruz.Linear search (Doğrusal Arama)Son olarak ilgili blok tespiti sonrası blok sınırlarımız [startIndex, endIndex] içerisinde linear search uyguluyoruz. Sonrasında eğer bu aralıkta aradığımız değeri tespit edersek mutlu son, tespit edemezsek aradığımız elemanın bu koleksiyonda olmadığı sonucuna varıyoruz. Yukarıdaki örneğe dönecek olursak [4,5] sınır değerlerine sahip bloğu taradığımızda aradığımız 91 değerinin 5. indexte olduğunu tespit etmiş oluyoruz.AnalizBest Case (En iyi durum) : En iyi durumu düşünecek olursak aslında ilk endIndex konumundaki değerin aradığım değer olması olacaktır. Bu durumda O(1) olacaktır.Worst Case (En kötü durum) : Aradığım değerin koleksiyonun sonundaki değer olduğu durum olacaktır. Block size hesabında √n değerinin optimum olduğunu görmüştük. Şimdi aynı denklemi √n ni yerine koyarak düşünürsek √n atlama + √n - 1 linear search = 2√n - 1 olur. Bu değerde karmaşıklık olarak O(√n) olacaktır.Buradan yola çıkarak koleksiyonumuz küçük boyutlardaysa aslında bu topa girmek bize ekstra maliyet doğuracağınıda söylemek yanlış olmaz. Direk linear search ten gidilebilmesi daha verimli olacaktır. Öte yandan bir video da belirli bir kareyi tespit etmek içinde jump search kullanmak verimli bir sonuç ortaya çıkarabilir.Analiz sonucunda algoritmanın karmaşıklık olarak kendisine linear ile binary arasında bir yer bulduğunu söyleyebiliriz. En yavaştan en hızlıya sıralarsak aşağıdaki gibi bir sonuç elde edilecektir.linear (n) &lt; jump (√n) &lt; binary (logn)" }, { "title": "Binary Search (İkili Arama)", "url": "/posts/binary-search/", "categories": "Algoritmalar, Arama Algoritmaları", "tags": "c#, arama algoritmaları, binary search, ikili arama", "date": "2019-08-23 11:33:00 +0300", "snippet": "Binary Search (İkili Arama) Nedir ?Oldukça popüler bir arama algoritması olan ikili arama sıralı koleksiyonlar üzerinde çalışan bir arama algoritmasıdır. Zaten bir nevi gücünü de verilerin sıralı biçimde olması üzerinden kazanır. Bu nedenle ikili aramayı sırasız bir koleksiyonda kullanmak istersek ilk önce bu koleksiyonun sıralanmasını gerektirir.Çalışma prensibi olarak arama uzayını azaltmaya dayalı bir yaklaşım benimser. Bu da bu arama tekniğinin hızlı çalışmasında büyük rol oynar. Algoritmayı okumak yerine izlemeyi tercih ederseniz. Youtube kanalımı ziyaret edebilirsiniz.Algoritmanın Kodupublic static bool binarySearch(int[] arr, int val) { int lowerBound = 0; int upperBound = arr.Length - 1; while (lowerBound &lt;= upperBound) { int mid = (upperBound + lowerBound) / 2; if (arr[mid] == val) { return true; } else if (arr[mid] &gt; val) { upperBound = mid - 1; } else { lowerBound = mid + 1; } } return false;}Algoritmanın DavranışıYukarıdaki kodu birlikte incelemeye başlayalım. Aşağıda arama yapmak istediğimiz koleksiyonumuzu görüyoruz. Burada aradığımız değerinde 11 olduğunu düşünelim.Binary search ilk olarak alt sınırı (lowerBound) ve üst sınırı (upperBound) ifade eden 2 adet işaretçi kullanır.Şimdi bu işaretçileri kullanarak orta nokta (mid) tespiti yapılır. int mid = (upperBound + lowerBound)/2;Sonrasında mid deki değer ile aradığımız değer karşılaştırılır. middeki değer aradığım ise bulmuşumdur, middeki değerden büyük bir değer ise lowerBound u mid + 1 konumuna, mid deki değerden küçük ise upperBound u mid - 1 konumuna çekeriz. Not : Bu bound (sınır) değerlerini oynattığımız anda arama uzayının yarısını elediğimize dikkat edin. (Şimdi neden sıralı koleksiyonları kullandığını görmüşsünüzdür, çünkü koleksiyonun sıralı olduğunu bildiğinden rahatça sınır değerini oynatabiliyor, sıralı olmadığı durumu hayal edin aradığınız değer koleksiyonunuzda olsa bile hiç ulaşamayabilirdiniz.)Devam edecek olursak, biz 11 i arıyorduk mid deki değer = 17. Dolayısıyla mid den daha küçük bir değer aradığımızdan kesinlikle ben mid in solunda bir konumdayımdır düşüncesi ile üst sınır mid - 1 konumununa çekilir.Tekrar mid hesaplanır. int mid = (upperBound + lowerBound)/2; bu sefer 0 konumu yeni mid olur.Bu sefer mid deki değer 7 ama benim aradığım 11 idi. Yani mid den büyüğüm. O zaman algoritma kesin ben mid in sağındayımdır düşüncesi ile, lowerBound u mid + 1 konumuna çeker.Tekrar mid hesaplanır ve mid = 1 olur ve middeki değerde 11 yani aradığım değer, işte bu kadar aradığımız değeri çok kısa bir sürede bulmuş oluyoruz. Uyarı :Bu noktada şuna da dikkat edilmesi önemli sınırların kesiştiği nokta son şansımız idi. Eğer bu noktada da bulamasak while (lowerBound &lt;= upperBound) olması sebebiyle döngüyü kıracaktık. Çünkü sınırlar kesiştikten sonra artık arama yapmanın bir anlamı olmayacaktı. Yani diğer bir cümle ile koleksiyonda artık bakılabilecek bir değerin kalmadığı ortaya çıkacaktı. Bizde aranan değerin bu koleksiyonda bulunmadığını dönecektik.AnalizBest Case (En iyi durum) : En iyi durum aslında ilk mid değerinin aradığım değer olmasıdır. Yani bir adım O(1) olacaktır.Worst Case (En kötü durum) : Bu da aslında yukarıdaki örneğimizde de olduğu gibi arama uzayında tek eleman kalıncaya kadar devam ettiğimiz senaryo olacaktır. Algoritma davranışı gereği her sınır değişiminde arama uzayı yarıya indiğinden karmaşıklığıda O(logn) olacaktır." }, { "title": "Linear Search (Doğrusal Arama)", "url": "/posts/linear-search/", "categories": "Algoritmalar, Arama Algoritmaları", "tags": "c#, arama algoritmaları, linear search, sıralı arama, doğrusal arama", "date": "2019-05-18 15:37:00 +0300", "snippet": "Linear Search (Doğrusal Arama) Nedir ?Linear search diğer adıyla doğrusal arama aradığımız değeri bir noktadan başlayıp ilgili arama dizesi bitene kadar aramaya devam eden en basit arama algoritmasıdır.Aşağıda ilgili dizede aranan değer var mı/yok mu ? arayan bir algoritma örneği bulunmaktadır.public static bool linearSearch(int[] arr, int val) { for (int i = 0; i &lt; arr.Length; i++) { if (arr[i] == val) { return true; } } return false;}// Example:// bool result = linearSearch(new int[] { 1, 2, 3, 4}, 4); // val = 4 ilgili dizede bulunduğu için true dönecektir.Eğer aranan değer var mı ? dan ziyade bulunduğu konumu almak istersek algoritmanın dönüş(return) değerini değiştirerek ilgili konumada ulaşabiliriz.public static int linearSearch(int[] arr, int val) { for (int i = 0; i &lt; arr.Length; i++) { if (arr[i] == val) { return i; } } return -1;}// Example:// int result = linearSearch(new int[] { 1, 2, 3, 4}, 4); // val = 4 ilgili dizede 3. indiste bulunduğu için 3 dönecektir.Tabi burada şunu farketmek iyi olacaktır. İlgili değer ile ilk karşılaşılan konumu dönecektir. Eğer tüm konumları almak istersek return etmek yerine bir koleksiyonda bu değerleri saklayıp en son bu koleksiyonu geriye dönebiliriz.public static List&lt;int&gt; linearSearch(int[] arr, int value) { List&lt;int&gt; findIndexes = new List&lt;int&gt;(); for (int i = 0; i &lt; arr.Length; i++) { if (arr[i] == value) { findIndexes.Add(i); } } return findIndexes;}// Example:// List&lt;int&gt; result = linearSearch(new int[] { 1, 2, 3, 4, 2 ,5}, 2); // val = 2 ilgili dizede 1. ve 3. indislerde olduğu görünmektedir. //Dolayısıyla dönen listemizde 1 ve 3 değerleri bulunacaktır. Not : Örneklere baktığımızda sadece sayılarla çalışıyor gibi anlaşılmasın, farklı veri türlerinde de ilgili yapıyı kurduğunuzda benzer sonuçlara erişebilirsiniz.AnalizBest Case (En iyi durum) : En iyi durum aslında sizlerinde tahmin edebileceği gibi aradığımız değerin koleksiyonun ilk değeri olması olacaktır. Bu durumda O(1) olacaktır. Yani bir adımda aradığımız değere ulaşabileceğimizi gösterir.Worst Case (En kötü durum) : Bu arama için en kötü durumu düşündüğümüzde aslında aradığımız değerin ilgili koleksiyonumuzun sonuncu değeri olması olacaktır. Ve koleksiyonumuzun n boyutunda olduğu düşünülecek olursa bu durumda O(n) olarak karşımıza çıkacaktır.Bu sonuçlar bize aslında bu algoritmanın büyüyen veri kümelerinde çok kullanılmaması gerektiği yönünde bazı emareler göstermektedir. Çünkü O(n) e baktığımızda koleksiyondaki veri miktarımız ile paralel bir şekilde ulaşım durumumuzda değişmektedir. Bu nedenle nispeden daha az değerle uğraşırken veya büyümeyeceğini düşündüğümüz koleksiyonlarda çalışırken kullanmak daha uygun bir tercih olacaktır.Farklı bir algoritma yazısında görüşünceye dek kendinize iyi bakın. İyi Çalışmalar" } ]
